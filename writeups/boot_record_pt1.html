<!--Add date: 08/13/2020-->

<h1>Media Drive Master Boot Record</h1>

<h2>Reverse Engineering Demonstration</h2>

<h3>Demo by YR81</h3>

<p>Attached below is an IDA listing of a master boot record of a flash drive formatted as FAT32. The master boot record resides in the first sector (Sector 1) of the disk image. It is identified by the filesystem type string at offset 0x52. When a computer tries to boot from the media, it will load this sector into memory at location 0x7c00 and branch to it. The boot record is then responsible for either loading the operating system or another, more complex loader.</p>

<p>In this case, no operating system is present on the media. All it does is load another sector (Sector 12) into memory at location 0x8000 and then jump there. Any time an error is encountered, the system will print a message and request the user to press a button to restart the boot process.</p>

<p>A useful reference when interpreting the boot record is Wikipedia's page on the <a href = "https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system" target = "_blank">FAT filesystem</a>.</p>

<pre class = "x86asm">
seg000:7C00 ;
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
seg000:7C00 ; |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
seg000:7C00 ; |                            Freeware version                             |
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 : 3F29BF94BF82DACE6272E5B038A3D99174A2AAD4A021DD260A400C8C33AC06AC
seg000:7C00 ; Input MD5    : C247D455DBDA8C5D9AF6B93771971987
seg000:7C00 ; Input CRC32  : 16D8FEA8
seg000:7C00
seg000:7C00 ; File Name   : C:\Users\********\Desktop\bootsec.bin
seg000:7C00 ; Format      : Binary file
seg000:7C00 ; Base Address: 0000h Range: 0000h - 0200h Loaded length: 0200h
seg000:7C00
seg000:7C00                 .686p
seg000:7C00                 .mmx
seg000:7C00                 .model flat
seg000:7C00
seg000:7C00 ; ===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Pure code
seg000:7C00 seg000          segment byte public 'CODE' use16
seg000:7C00                 assume cs:seg000
seg000:7C00                 ;org 7C00h
seg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:7C00
seg000:7C00 ; =============== S U B R O U T I N E =======================================
seg000:7C00
seg000:7C00
seg000:7C00 boot            proc near
seg000:7C00                 jmp     short loc_7C5A  ; cx = 0
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C02 extAvail        db 90h
seg000:7C03 oemName         db 4Dh, 53h, 44h, 4Fh, 53h, 35h, 2Eh, 30h ; "MSDOS5.0"
seg000:7C0B bytesPerSector  dw 200h
seg000:7C0D sectorsPerCluster db 8
seg000:7C0E reservedSectors dw 26h
seg000:7C10 FATs            db 2
seg000:7C11 maxFATEntries   dw 0                    ; not used in FAT32
seg000:7C13 sectors         dw 0                    ; not used in FAT32
seg000:7C13                                         ; see sectors32
seg000:7C15 mediaType       db 0F8h                 ; fixed disk
seg000:7C16 sectorsPerFAT   dw 0                    ; not used in FAT32
seg000:7C16                                         ; see sectorsPerFAT32
seg000:7C18 sectorsPerCyl   dw 3Fh
seg000:7C1A heads           dw 0FFh
seg000:7C1C hiddenSectors   dd 2560h
seg000:7C20 sectors32       dd 0F39AA0h
seg000:7C24 sectorsPerFAT32 dd 3CC9h
seg000:7C28 driveDesc       dw 0
seg000:7C2A version         dw 0
seg000:7C2C rootDirectoryCluster dd 2
seg000:7C30 FSInfo          dw 1
seg000:7C32 copyBootSec     dw 6
seg000:7C34                 db 0Ch dup(0)           ; reserved
seg000:7C40 drive           db 0
seg000:7C41                 db 1                    ; reserved
seg000:7C42 extendedBootSignature db 29h
seg000:7C43 volID           dd 0B4E6158Ah
seg000:7C47 volLbl          db 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h, 4 dup(20h) ; "NO_NAME____"
seg000:7C52 fsType          db 46h, 41h, 54h, 33h, 32h, 3 dup(20h) ; "FAT32___"
seg000:7C5A ; ---------------------------------------------------------------------------
seg000:7C5A
seg000:7C5A loc_7C5A:                               ; CODE XREF: boot↑j
seg000:7C5A                 xor     cx, cx          ; cx = 0
seg000:7C5C                 mov     ss, cx          ; initialize stack segment to 0x0
seg000:7C5E                 mov     sp, 7BF4h       ; initialize stack pointer to 0x7bf4
seg000:7C61                 mov     es, cx          ; initialize extra segment to 0x0
seg000:7C63                 mov     ds, cx          ; initialize data segment to 0x0
seg000:7C65                 mov     bp, 7C00h       ; initialize base pointer to 0x7c00 (base of MBR)
seg000:7C68                 mov     [bp+2], cl      ; clear extensions flag
seg000:7C6B                 mov     dl, [bp+40h]    ; dl = physical drive number
seg000:7C6E                 mov     ah, 8           ; ah = 8 -> read drive parameters
seg000:7C70                 int     13h             ; $!
seg000:7C72                 jnb     short loc_7C79  ; check if interrupt call errored
seg000:7C74                 mov     cx, 0FFFFh      ; if error, set logical last index of cylinders to 0x3ff
seg000:7C74                                         ; and logical last index of sectors per cylinder to 0x3f
seg000:7C77                 mov     dh, cl          ; if error, set logical last index of heads to 0xff
seg000:7C79
seg000:7C79 loc_7C79:                               ; CODE XREF: boot+72↑j
seg000:7C79                 movzx   eax, dh         ; logical last index of heads
seg000:7C7D                 inc     ax              ; get the total number of heads
seg000:7C7D                                         ; (= logical last index + 1)
seg000:7C7E                 movzx   edx, cl         ; prepare to get number of sectors / cylinder
seg000:7C82                 and     dl, 3Fh         ; get lowest 6 bits -> number of sectors per cylinder
seg000:7C85                 mul     dx              ; dx:ax = number of heads * sectors per cylinder
seg000:7C87                 xchg    cl, ch          ; prepare to get logical last index of cylinders
seg000:7C89                 shr     ch, 6           ; get original CL[7:6]..CH[7:0] = logical last index of cylinders
seg000:7C8C                 inc     cx              ; get number of cylinders
seg000:7C8C                                         ; (= logical last index + 1)
seg000:7C8D                 movzx   ecx, cx         ; clear upper word of ecx
seg000:7C91                 mul     ecx             ; edx:eax = number of heads * sectors per cylinder * cylinders
seg000:7C91                                         ; = total number of sectors
seg000:7C94                 mov     [bp-8], eax     ; save the total number of sectors
seg000:7C98                 cmp     word ptr [bp+16h], 0 ; check logical sectors per FAT (0 if FAT32)
seg000:7C9C                 jnz     short loc_7CD6  ; -> "Remove disks or other media."
seg000:7C9E
seg000:7C9E FAT32:                                  ; check version (should be 0.0 in FAT32)
seg000:7C9E                 cmp     word ptr [bp+2Ah], 0
seg000:7CA2                 ja      short loc_7CD6  ; -> "Remove disks or other media."
seg000:7CA4                 mov     eax, [bp+1Ch]   ; get number of hidden sectors
seg000:7CA8                 add     eax, 0Ch        ; move to sector 12 of this partition
seg000:7CAC                 mov     bx, 8000h       ; read to location 0x8000
seg000:7CAF                 mov     cx, 1           ; read 1 sector
seg000:7CB2                 call    readSectors     ; save registers
seg000:7CB5                 jmp     near ptr 8000h  ; jump to the loaded boot segment
seg000:7CB8 ; ---------------------------------------------------------------------------
seg000:7CB8
seg000:7CB8 loc_7CB8:                               ; CODE XREF: readSectors+80↓j
seg000:7CB8                 mov     al, ds:offs_diskError ; -> "Disk error."
seg000:7CBB
seg000:7CBB loc_7CBB:                               ; CODE XREF: boot+D4↓j
seg000:7CBB                                         ; boot+D9↓j
seg000:7CBB                 mov     ah, 7Dh ; '}'   ; base of string lookup = 0x7d00
seg000:7CBD                 mov     si, ax
seg000:7CBF
seg000:7CBF loc_7CBF:                               ; CODE XREF: boot+CF↓j
seg000:7CBF                 lodsb                   ; get character
seg000:7CC0                 test    al, al          ; check if NULL
seg000:7CC2                 jz      short loc_7CDB  ; if NULL, wait on keypress and restart boot
seg000:7CC4                 cmp     al, 0FFh        ; byte indicating keypress prompt
seg000:7CC6                 jz      short loc_7CD1  ; -> "Press any key to restart."
seg000:7CC8                 mov     ah, 0Eh         ; ah = 0xe -> teletype output
seg000:7CCA                 mov     bx, 7           ; bh = 0 -> page 0
seg000:7CCA                                         ; bl = 0x7 -> light grey on black
seg000:7CCD                 int     10h             ; $!
seg000:7CCF                 jmp     short loc_7CBF  ; get character
seg000:7CD1 ; ---------------------------------------------------------------------------
seg000:7CD1
seg000:7CD1 loc_7CD1:                               ; CODE XREF: boot+C6↑j
seg000:7CD1                 mov     al, ds:offs_pressKey ; -> "Press any key to restart."
seg000:7CD4                 jmp     short loc_7CBB  ; base of string lookup = 0x7d00
seg000:7CD6 ; ---------------------------------------------------------------------------
seg000:7CD6
seg000:7CD6 loc_7CD6:                               ; CODE XREF: boot+9C↑j
seg000:7CD6                                         ; boot+A2↑j
seg000:7CD6                 mov     al, ds:offs_removeDisks ; -> "Remove disks or other media."
seg000:7CD9                 jmp     short loc_7CBB  ; base of string lookup = 0x7d00
seg000:7CDB ; ---------------------------------------------------------------------------
seg000:7CDB
seg000:7CDB loc_7CDB:                               ; CODE XREF: boot+C2↑j
seg000:7CDB                 cbw
seg000:7CDC                 int     16h             ; $!
seg000:7CDE                 int     19h             ; $!
seg000:7CDE boot            endp
seg000:7CDE
seg000:7CE0
seg000:7CE0 ; =============== S U B R O U T I N E =======================================
seg000:7CE0
seg000:7CE0 ; save registers
seg000:7CE0
seg000:7CE0 readSectors     proc near               ; CODE XREF: boot+B2↑p
seg000:7CE0                                         ; readSectors+8B↓j
seg000:7CE0                 pushad
seg000:7CE2                 cmp     eax, [bp-8]     ; compare desired sector number with total number of sectors
seg000:7CE6                 jb      loc_7D34        ; clear upper dword for division
seg000:7CEA                 push    large 0         ; set up disk access packet
seg000:7CEA                                         ; high dword of sector number = 0
seg000:7CED                 push    eax             ; low dword of sector number
seg000:7CEF                 push    es              ; segment where data should be transferred
seg000:7CF0                 push    bx              ; offset where data should be transferred
seg000:7CF1                 push    large 10010h    ; size of DAP = 0x10
seg000:7CF1                                         ; unused = 0
seg000:7CF1                                         ; number of sectors to be read = 1
seg000:7CF7                 cmp     byte ptr [bp+2], 0 ; see if we can used extended disk read
seg000:7CFB                 jnz     loc_7D1F        ; ah = 0x42 -> extended read sectors from drive
seg000:7CFF                 mov     ah, 41h ; 'A'   ; ah = 0x41 -> check if extensions are present
seg000:7D01                 mov     bx, 55AAh       ; bx = 0x55aa -> magic number
seg000:7D04                 mov     dl, [bp+40h]    ; dl = disk number
seg000:7D07                 int     13h             ; $!
seg000:7D09                 jb      loc_7D29        ; if execution reaches this address, indicate error
seg000:7D0D                 cmp     bx, 0AA55h      ; check for error by comparing returned bx with 0xaa55
seg000:7D11                 jnz     loc_7D29        ; if execution reaches this address, indicate error
seg000:7D15                 test    cl, 1           ; see if device supports packet access
seg000:7D18                 jz      loc_7D29        ; if execution reaches this address, indicate error
seg000:7D1C                 inc     byte ptr [bp+2] ; set the disk extensions flag
seg000:7D1F
seg000:7D1F loc_7D1F:                               ; CODE XREF: readSectors+1B↑j
seg000:7D1F                 mov     ah, 42h ; 'B'   ; ah = 0x42 -> extended read sectors from drive
seg000:7D21                 mov     dl, [bp+40h]    ; dl = drive number
seg000:7D24                 mov     si, sp          ; si -> disk access packet
seg000:7D26                 int     13h             ; $!
seg000:7D28                 nop                     ; patched byte (original = 0xb0)
seg000:7D28                                         ; if we get here, move 0xf4 to ax and continue with pop eax
seg000:7D28                                         ; carry flag is set depending on result of int 13h
seg000:7D29
seg000:7D29 loc_7D29:                               ; CODE XREF: readSectors+29↑j
seg000:7D29                                         ; readSectors+31↑j ...
seg000:7D29                 stc                     ; if execution reaches this address, indicate error
seg000:7D2A                 pop     eax             ; pop off the disk access packet
seg000:7D2C                 pop     eax
seg000:7D2E                 pop     eax
seg000:7D30                 pop     eax
seg000:7D32                 jmp     short loc_7D5E  ; restore registers
seg000:7D34 ; ---------------------------------------------------------------------------
seg000:7D34
seg000:7D34 loc_7D34:                               ; CODE XREF: readSectors+6↑j
seg000:7D34                 xor     edx, edx        ; clear upper dword for division
seg000:7D37                 movzx   ecx, word ptr [bp+18h] ; physical sectors per cylinder
seg000:7D3C                 div     ecx             ; divide by sectors / cylinder
seg000:7D3F                 inc     dl              ; get remainder + 1 = sector number
seg000:7D41                 mov     cl, dl          ; cl = sector number
seg000:7D43                 mov     edx, eax        ; quotient = cylinder number
seg000:7D46                 shr     edx, 10h        ; get highest two bits of cylinder number
seg000:7D4A                 div     word ptr [bp+1Ah] ; divide by number of heads
seg000:7D4D                 xchg    dl, dh          ; move highest two bits of cylinder number into dh
seg000:7D4F                 mov     dl, [bp+40h]    ; dl = drive number
seg000:7D52                 mov     ch, al          ; lowest 8 bits of cylinder number go to ch
seg000:7D54                 shl     ah, 6           ; highest two bits of cylinder in highest two bits of cl
seg000:7D57                 or      cl, ah          ; lowest 6 bits from sector number
seg000:7D59                 mov     ax, 201h        ; ah = 2 -> read sectors from drive
seg000:7D59                                         ; al = 1 -> read 1 sector
seg000:7D5C                 int     13h             ; $!
seg000:7D5E
seg000:7D5E loc_7D5E:                               ; CODE XREF: readSectors+52↑j
seg000:7D5E                 popad                   ; restore registers
seg000:7D60                 jb      loc_7CB8        ; -> "Disk error."
seg000:7D64                 add     bx, 200h        ; add 0x200 to memory location
seg000:7D68                 inc     eax             ; increment sector number
seg000:7D6A                 dec     cx              ; decrement number of sectors to read
seg000:7D6B                 jnz     readSectors     ; save registers
seg000:7D6F                 retn
seg000:7D6F readSectors     endp
seg000:7D6F
seg000:7D6F ; ---------------------------------------------------------------------------
seg000:7D70                 db  4Eh ; N
seg000:7D71                 db  54h ; T
seg000:7D72                 db  4Ch ; L
seg000:7D73                 db  44h ; D
seg000:7D74                 db  52h ; R
seg000:7D75                 db  20h
seg000:7D76                 db  20h
seg000:7D77                 db  20h
seg000:7D78                 db  20h
seg000:7D79                 db  20h
seg000:7D7A                 db  20h
seg000:7D7B                 db    0
seg000:7D7C                 db    0
seg000:7D7D                 db    0
seg000:7D7E                 db    0
seg000:7D7F                 db    0
seg000:7D80                 db    0
seg000:7D81                 db    0
seg000:7D82                 db    0
seg000:7D83                 db    0
seg000:7D84                 db    0
seg000:7D85                 db    0
seg000:7D86                 db    0
seg000:7D87                 db    0
seg000:7D88                 db    0
seg000:7D89                 db    0
seg000:7D8A                 db    0
seg000:7D8B                 db    0
seg000:7D8C                 db    0
seg000:7D8D                 db    0
seg000:7D8E                 db    0
seg000:7D8F                 db    0
seg000:7D90                 db    0
seg000:7D91                 db    0
seg000:7D92                 db    0
seg000:7D93                 db    0
seg000:7D94                 db    0
seg000:7D95                 db    0
seg000:7D96                 db    0
seg000:7D97                 db    0
seg000:7D98                 db    0
seg000:7D99                 db    0
seg000:7D9A                 db    0
seg000:7D9B                 db    0
seg000:7D9C                 db    0
seg000:7D9D                 db    0
seg000:7D9E                 db    0
seg000:7D9F                 db    0
seg000:7DA0                 db    0
seg000:7DA1                 db    0
seg000:7DA2                 db    0
seg000:7DA3                 db    0
seg000:7DA4                 db    0
seg000:7DA5                 db    0
seg000:7DA6                 db    0
seg000:7DA7                 db    0
seg000:7DA8                 db    0
seg000:7DA9                 db    0
seg000:7DAA                 db    0
seg000:7DAB                 db    0
seg000:7DAC aRemoveDisksOrO db 0Dh,0Ah
seg000:7DAC                 db 'Remove disks or other media.'
seg000:7DCA                 db 0FFh
seg000:7DCB aDiskError      db 0Dh,0Ah
seg000:7DCB                 db 'Disk error'
seg000:7DD7                 db 0FFh
seg000:7DD8 aPressAnyKeyToR db 0Dh,0Ah
seg000:7DD8                 db 'Press any key to restart',0Dh,0Ah,0
seg000:7DF5                 db    0
seg000:7DF6                 db    0
seg000:7DF7                 db    0
seg000:7DF8                 db    0
seg000:7DF9 offs_removeDisks db 0ACh                ; DATA XREF: boot:loc_7CD6↑r
seg000:7DFA offs_diskError  db 0CBh                 ; DATA XREF: boot:loc_7CB8↑r
seg000:7DFB offs_pressKey   db 0D8h                 ; DATA XREF: boot:loc_7CD1↑r
seg000:7DFC                 db    0
seg000:7DFD                 db    0
seg000:7DFE bootSectorSignature dw 0AA55h
seg000:7DFE seg000          ends
seg000:7DFE
seg000:7DFE
seg000:7DFE                 end
</pre>